<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Dispatch JDR</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>

<main class="app">

  <section class="panel panel-left">
    <header class="panel-header">
      <h1 class="title">Dispatch JDR</h1>
      <p class="subtitle">Test de compétence</p>
    </header>

    <div class="group">
      <h2 class="group-title">Personnage</h2>

      <div class="id-card">
        <img id="portrait" class="portrait" src="" alt="Portrait personnage" />
        <div class="id-info">
          <div id="charName" class="char-name">—</div>
          <select id="characterSelect" class="char-select"></select>
        </div>
      </div>
    </div>

    <div class="group">
      <h2 class="group-title">Stats requises</h2>
      <div id="reqControls" class="controls"></div>
    </div>

    <div class="actions">
      <button id="rollBtn" class="btn">Lancer</button>
      <div id="result" class="result">—</div>
    </div>
  </section>

  <section class="panel panel-right">
    <header class="panel-header">
      <h2 class="group-title">Résolution</h2>
    </header>

    <div class="canvas-wrap">
      <canvas id="c" width="760" height="520"></canvas>
    </div>
  </section>

</main>

<script>
(() => {

  const STATS = ["Force","Vigueur","Mobilité","Charisme","Intelligence"];
  const MAX_STAT = 10;

  const ICONS = {
    Force: "icons/Force.png",
    Vigueur: "icons/Vigueur.png",
    Mobilité: "icons/Mobilité.png",
    Charisme: "icons/Charisme.png",
    Intelligence: "icons/Intelligence.png",
  };

  const CHARACTER_FILES = [
    "personnages/perso_01.json",
    "personnages/perso_02.json",
    "personnages/perso_03.json"
  ];

  const COL = {
    panelBg: "#fff0d9",
    pentFill: "#322a1f",
    grid: "#615a43",
    charFill: "rgba(255,199,58,0.40)",
    charStroke: "rgba(255,199,58,1)",
    reqFill: "rgba(255,255,249,0.40)",
    reqStroke: "rgba(255,255,249,1)",
    puckRolling: "#000000",
    puckSuccess: "#6dc383",
    puckFail: "#f98277"
  };

  const MIN_DURATION = 7.0;
  const MAX_DURATION = 9.0;
  const START_SPEED  = 360;
  const FRICTION     = 0.992;
  const STOP_SPEED   = 18;
  const MAX_BOUNCES  = 40;

  const char = { Force:0, Vigueur:0, Mobilité:0, Charisme:0, Intelligence:0 };
  const req  = { Force:2, Vigueur:2, Mobilité:5, Charisme:5, Intelligence:2 };

  let characters = [];

  const portraitImg = document.getElementById("portrait");
  const charNameEl  = document.getElementById("charName");
  const selectEl    = document.getElementById("characterSelect");
  const reqControls = document.getElementById("reqControls");
  const rollBtn     = document.getElementById("rollBtn");
  const resultEl    = document.getElementById("result");

  function mkSlider(container, obj, key) {
    const row = document.createElement("div");
    row.className = "row";

    const label = document.createElement("label");
    label.className = "lbl";
    label.textContent = key;

    const val = document.createElement("div");
    val.className = "val";
    val.textContent = obj[key];

    const rng = document.createElement("input");
    rng.className = "rng";
    rng.type = "range";
    rng.min = 0;
    rng.max = MAX_STAT;
    rng.value = obj[key];

    rng.addEventListener("input", () => {
      obj[key] = Number(rng.value);
      val.textContent = obj[key];
      draw();
    });

    row.append(label, val);
    container.append(row, rng);
  }

  STATS.forEach(k => mkSlider(reqControls, req, k));

  async function loadCharacters() {
    const data = await Promise.all(
      CHARACTER_FILES.map(f => fetch(f).then(r => r.json()))
    );

    characters = data;
    selectEl.innerHTML = "";

    data.forEach((c, i) => {
      const opt = document.createElement("option");
      opt.value = i;
      opt.textContent = c.nom;
      selectEl.appendChild(opt);
    });

    selectCharacter(0);
  }

  function selectCharacter(index) {
    const c = characters[index];
    Object.assign(char, c.stats);
    portraitImg.src = c.portrait;
    charNameEl.textContent = c.nom;
    draw();
  }

  selectEl.addEventListener("change", e => {
    selectCharacter(e.target.value);
  });

  const iconImgs = {};
  let iconsReady = false;

  function loadIcons() {
    const promises = STATS.map(k => new Promise((resolve) => {
      const img = new Image();
      img.onload = () => resolve(true);
      img.onerror = () => resolve(false);
      img.src = ICONS[k];
      iconImgs[k] = img;
    }));
    Promise.all(promises).then(() => {
      iconsReady = true;
      draw();
    });
  }

  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  const cx = canvas.width * 0.55;
  const cy = canvas.height * 0.52;
  const R  = Math.min(canvas.width, canvas.height) * 0.38;

  function deg(d){ return d * Math.PI / 180; }
  function add(a,b){ return {x:a.x+b.x,y:a.y+b.y}; }
  function mul(v,s){ return {x:v.x*s,y:v.y*s}; }
  function norm(v){ return Math.hypot(v.x,v.y) || 1e-9; }

  function polygonFromStats(o){
    return STATS.map((k,i)=>{
      const a = deg(-90 + i*72);
      const r = (o[k]/MAX_STAT)*R;
      return { x: cx + Math.cos(a)*r, y: cy + Math.sin(a)*r };
    });
  }

  function pointInPoly(p, poly){
    let inside = false;
    for(let i=0,j=poly.length-1;i<poly.length;j=i++){
      const a=poly[i], b=poly[j];
      if(((a.y>p.y)!=(b.y>p.y)) &&
         p.x < (b.x-a.x)*(p.y-a.y)/(b.y-a.y)+a.x)
        inside = !inside;
    }
    return inside;
  }

  function polygonCentroid(poly){
    let x=0,y=0;
    poly.forEach(p=>{x+=p.x;y+=p.y});
    return {x:x/poly.length,y:y/poly.length};
  }

  const puck = {
    active:false,
    state:"idle",
    pos:{x:cx,y:cy},
    vel:{x:0,y:0},
    r:8,
    time:0,
    bounces:0
  };

  function startRoll(){
    const reqPoly = polygonFromStats(req);
    const c = polygonCentroid(reqPoly);

    puck.active = true;
    puck.state = "rolling";
    puck.pos = {...c};
    puck.time = 0;
    puck.bounces = 0;

    const a = Math.random()*Math.PI*2;
    puck.vel = {x:Math.cos(a)*START_SPEED,y:Math.sin(a)*START_SPEED};

    resultEl.textContent = "…";
    resultEl.className = "result";
  }

  function update(dt){
    if(!puck.active) return;

    const reqPoly = polygonFromStats(req);
    const next = add(puck.pos,mul(puck.vel,dt));

    puck.vel = mul(puck.vel,FRICTION);

    if(!pointInPoly(next,reqPoly)){
      puck.vel.x*=-1;
      puck.vel.y*=-1;
      puck.bounces++;
    } else puck.pos = next;

    puck.time += dt;

    const speed = norm(puck.vel);
    if(puck.time>=MIN_DURATION &&
      (speed<STOP_SPEED || puck.time>MAX_DURATION || puck.bounces>MAX_BOUNCES)){
      puck.active=false;
      puck.state = pointInPoly(puck.pos,polygonFromStats(char))?"success":"fail";
      resultEl.textContent = puck.state==="success"?"Succès":"Échec";
      resultEl.className = "result "+(puck.state==="success"?"ok":"no");
    }
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    ctx.fillStyle = COL.panelBg;
    ctx.fillRect(0,0,canvas.width,canvas.height);

    const outer = polygonFromStats({
      Force:10,Vigueur:10,Mobilité:10,Charisme:10,Intelligence:10
    });

    drawPoly(outer,COL.pentFill,null);
    drawGrid();

    drawPoly(polygonFromStats(req),COL.reqFill,COL.reqStroke,2);
    drawPoly(polygonFromStats(char),COL.charFill,COL.charStroke,2.5);

    drawIcons();
    drawPuck();
  }

  function drawPoly(pts,fill,stroke,w=1){
    ctx.beginPath();
    pts.forEach((p,i)=>i?ctx.lineTo(p.x,p.y):ctx.moveTo(p.x,p.y));
    ctx.closePath();
    if(fill){ctx.fillStyle=fill;ctx.fill();}
    if(stroke){ctx.strokeStyle=stroke;ctx.lineWidth=w;ctx.stroke();}
  }

  function drawGrid(){
    ctx.strokeStyle = COL.grid;
    ctx.lineWidth = 1;
    for(let k=2;k<=10;k+=2){
      const r=(k/10)*R;
      ctx.beginPath();
      STATS.forEach((_,i)=>{
        const a=deg(-90+i*72);
        const x=cx+Math.cos(a)*r,y=cy+Math.sin(a)*r;
        i?ctx.lineTo(x,y):ctx.moveTo(x,y);
      });
      ctx.closePath();ctx.stroke();
    }
  }

  function drawIcons(){
    if(!iconsReady) return;

    const iconSize = 34;
    const radius = R + 30;

    for (let i=0; i<STATS.length; i++) {
      const key = STATS[i];
      const img = iconImgs[key];
      if (!img || !img.complete) continue;

      const a = deg(-90 + i*72);
      const x = cx + Math.cos(a)*radius;
      const y = cy + Math.sin(a)*radius;

      ctx.save();
      ctx.beginPath();
      ctx.arc(x, y, iconSize/2 + 8, 0, Math.PI*2);
      ctx.fillStyle = "rgba(255,240,217,0.92)";
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(48,28,2,0.35)";
      ctx.stroke();

      ctx.drawImage(img, x - iconSize/2, y - iconSize/2, iconSize, iconSize);
      ctx.restore();
    }
  }

  function drawPuck(){
    let c = COL.puckRolling;
    if(puck.state==="success") c=COL.puckSuccess;
    if(puck.state==="fail") c=COL.puckFail;

    ctx.beginPath();
    ctx.arc(puck.pos.x,puck.pos.y,puck.r,0,Math.PI*2);
    ctx.fillStyle=c;
    ctx.fill();
  }

  let last=performance.now();
  function loop(t){
    const dt=Math.min(0.033,(t-last)/1000);
    last=t;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  rollBtn.addEventListener("click",startRoll);
  loadIcons();
  loadCharacters();
  requestAnimationFrame(loop);

})();
</script>

</body>
</html>
