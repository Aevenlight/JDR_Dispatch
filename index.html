<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Dispatch JDR</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>

<main class="app">

  <section class="panel panel-left">
    <header class="panel-header">
      <img src="SDN_Logotype.png" alt="Dispatch JDR" class="logo" />
    </header>

    <div class="group">
      <h2 class="group-title">Personnage</h2>

      <div class="id-card">
        <img id="portrait" class="portrait" src="" alt="Portrait personnage" />
        <div class="id-info">
          <div id="charName" class="char-name">—</div>
          <select id="characterSelect" class="char-select"></select>
        </div>
      </div>
    </div>

    <div class="group">
      <h2 class="group-title">Stats requises</h2>
      <div id="reqControls" class="controls"></div>
    </div>

    <div class="actions">
      <button id="rollBtn" class="btn">Lancer</button>
      <div id="result" class="result">—</div>
    </div>
  </section>

  <section class="panel panel-right">
    <header class="panel-header">
    </header>

    <div class="canvas-wrap">
      <canvas id="c" width="760" height="520"></canvas>
    </div>
  </section>

</main>

<script>
(() => {
  const STATS = ["Force","Vigueur","Mobilité","Charisme","Intelligence"];
  const MAX_STAT = 10;

  const ICONS = {
    Force: "icons/Force.png",
    Vigueur: "icons/Vigueur.png",
    Mobilité: "icons/Mobilité.png",
    Charisme: "icons/Charisme.png",
    Intelligence: "icons/Intelligence.png",
  };

  const CHARACTER_FILES = [
    "personnages/perso_01.json",
    "personnages/perso_02.json",
    "personnages/perso_03.json"
  ];

  const COL = {
    panelBg: "#fff0d9",
    pentFill: "#322a1f",
    grid: "#615a43",
    charFill: "rgba(255,199,58,0.40)",
    charStroke: "rgba(255,199,58,1)",
    reqFill: "rgba(255,255,249,0.40)",
    reqStroke: "rgba(255,255,249,1)",
    puckRolling: "#000000",
    puckSuccess: "#6dc383",
    puckFail: "#f98277"
  };

  const MIN_DURATION = 7.0;
  const MAX_DURATION = 9.0;
  const START_SPEED  = 360;
  const FRICTION     = 0.992;
  const STOP_SPEED   = 18;
  const MAX_BOUNCES  = 40;

  const char = { Force:0, Vigueur:0, Mobilité:0, Charisme:0, Intelligence:0 };
  const req  = { Force:2, Vigueur:2, Mobilité:5, Charisme:5, Intelligence:2 };

  let characters = [];

  const portraitImg = document.getElementById("portrait");
  const charNameEl  = document.getElementById("charName");
  const selectEl    = document.getElementById("characterSelect");
  const reqControls = document.getElementById("reqControls");
  const rollBtn     = document.getElementById("rollBtn");
  const resultEl    = document.getElementById("result");

  function mkSlider(container, obj, key) {
    const row = document.createElement("div");
    row.className = "row";

    const label = document.createElement("label");
    label.className = "lbl";
    label.textContent = key;

    const val = document.createElement("div");
    val.className = "val";
    val.textContent = obj[key];

    const rng = document.createElement("input");
    rng.className = "rng";
    rng.type = "range";
    rng.min = 0;
    rng.max = MAX_STAT;
    rng.value = obj[key];

    rng.addEventListener("input", () => {
      obj[key] = Number(rng.value);
      val.textContent = obj[key];
      draw();
    });

    row.append(label, val);
    container.append(row, rng);
  }

  STATS.forEach(k => mkSlider(reqControls, req, k));

  async function loadCharacters() {
    const data = await Promise.all(
      CHARACTER_FILES.map(f => fetch(f).then(r => r.json()))
    );

    characters = data;
    selectEl.innerHTML = "";

    data.forEach((c, i) => {
      const opt = document.createElement("option");
      opt.value = i;
      opt.textContent = c.nom;
      selectEl.appendChild(opt);
    });

    selectCharacter(0);
  }

  function selectCharacter(index) {
    const c = characters[index];
    Object.assign(char, c.stats);
    portraitImg.src = c.portrait;
    charNameEl.textContent = c.nom;
    draw();
  }

  selectEl.addEventListener("change", e => {
    selectCharacter(e.target.value);
  });

  const iconImgs = {};
  let iconsReady = false;

  function loadIcons() {
    const promises = STATS.map(k => new Promise((resolve) => {
      const img = new Image();
      img.onload = () => resolve(true);
      img.onerror = () => resolve(false);
      img.src = ICONS[k];
      iconImgs[k] = img;
    }));
    Promise.all(promises).then(() => {
      iconsReady = true;
      draw();
    });
  }

  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  const dpr = window.devicePixelRatio || 1;
  const cssW = canvas.width;
  const cssH = canvas.height;
  canvas.style.width = cssW + "px";
  canvas.style.height = cssH + "px";
  canvas.width = Math.floor(cssW * dpr);
  canvas.height = Math.floor(cssH * dpr);
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

  const cx = cssW * 0.55;
  const cy = cssH * 0.52;
  const R  = Math.min(cssW, cssH) * 0.38;

  function deg(d){ return d * Math.PI / 180; }
  function add(a,b){ return {x:a.x+b.x,y:a.y+b.y}; }
  function sub(a,b){ return {x:a.x-b.x,y:a.y-b.y}; }
  function mul(v,s){ return {x:v.x*s,y:v.y*s}; }
  function dot(a,b){ return a.x*b.x + a.y*b.y; }
  function norm(v){ return Math.hypot(v.x,v.y) || 1e-9; }

  function randomUnit() {
    const a = Math.random() * Math.PI * 2;
    return { x: Math.cos(a), y: Math.sin(a) };
  }

  function polygonFromStats(o){
    return STATS.map((k,i)=>{
      const a = deg(-90 + i*72);
      const r = (o[k]/MAX_STAT)*R;
      return { x: cx + Math.cos(a)*r, y: cy + Math.sin(a)*r };
    });
  }

  function pointInPoly(p, poly){
    let inside = false;
    for(let i=0,j=poly.length-1;i<poly.length;j=i++){
      const a=poly[i], b=poly[j];
      if(((a.y>p.y)!=(b.y>p.y)) &&
         p.x < (b.x-a.x)*(p.y-a.y)/(b.y-a.y)+a.x)
        inside = !inside;
    }
    return inside;
  }

  function polygonCentroid(poly){
    let x=0,y=0;
    poly.forEach(p=>{x+=p.x;y+=p.y});
    return {x:x/poly.length,y:y/poly.length};
  }

  function closestPointOnSegment(p, a, b) {
    const ab = sub(b,a);
    const ap = sub(p,a);
    const ab2 = dot(ab,ab) || 1e-9;
    let t = dot(ap,ab)/ab2;
    t = Math.max(0, Math.min(1, t));
    return { x: a.x + ab.x*t, y: a.y + ab.y*t, t };
  }

  function nearestEdge(poly, p) {
    let best = { dist: Infinity, a: null, b: null, cp: null };
    for (let i=0; i<poly.length; i++) {
      const a = poly[i];
      const b = poly[(i+1)%poly.length];
      const cp = closestPointOnSegment(p, a, b);
      const dx = p.x - cp.x, dy = p.y - cp.y;
      const dist = Math.hypot(dx,dy);
      if (dist < best.dist) best = { dist, a, b, cp };
    }
    return best;
  }

  function reflect(v, nUnit) {
    const d = dot(v, nUnit);
    return { x: v.x - 2*d*nUnit.x, y: v.y - 2*d*nUnit.y };
  }

  let audioCtx = null;
  const soundBuffers = { success: null, fail: null, bounces: [] };
  let soundsLoaded = false;
  let lastBounceSoundAt = 0;

  function ensureAudio() {
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }

  async function loadBuffer(url) {
    const res = await fetch(url);
    if (!res.ok) throw new Error("Sound missing: " + url);
    const arr = await res.arrayBuffer();
    return await audioCtx.decodeAudioData(arr);
  }

  async function loadSounds() {
    if (soundsLoaded || !audioCtx) return;

    const bounceFiles = Array.from({length:7}, (_,i)=>`sounds/PinBounce_0${i+1}.wav`);
    const bouncePromises = bounceFiles.map(loadBuffer);

    const [successBuf, failBuf, bounceBufs] = await Promise.all([
      loadBuffer("sounds/Success.wav"),
      loadBuffer("sounds/Fail.wav"),
      Promise.all(bouncePromises)
    ]);

    soundBuffers.success = successBuf;
    soundBuffers.fail = failBuf;
    soundBuffers.bounces = bounceBufs;
    soundsLoaded = true;
  }

  function playBuffer(buf, vol=0.35, rate=1) {
    if (!audioCtx || !buf) return;
    const src = audioCtx.createBufferSource();
    const gain = audioCtx.createGain();
    src.buffer = buf;
    src.playbackRate.value = rate;
    gain.gain.value = vol;
    src.connect(gain).connect(audioCtx.destination);
    src.start();
  }

  function playRandomBounce(impact=1) {
    if (!soundsLoaded || soundBuffers.bounces.length === 0) return;

    const now = performance.now();
    if (now - lastBounceSoundAt < 55) return;
    lastBounceSoundAt = now;

    const idx = (Math.random() * soundBuffers.bounces.length) | 0;
    const buf = soundBuffers.bounces[idx];

    const vol = Math.min(0.45, 0.12 + 0.22 * impact);
    const rate = 0.95 + Math.random() * 0.10;

    playBuffer(buf, vol, rate);
  }

  function playSuccess() {
    if (!soundsLoaded) return;
    playBuffer(soundBuffers.success, 0.6, 1);
  }

  function playFail() {
    if (!soundsLoaded) return;
    playBuffer(soundBuffers.fail, 0.6, 1);
  }

  const puck = {
    active:false,
    state:"idle",
    pos:{x:cx,y:cy},
    vel:{x:0,y:0},
    r:8,
    time:0,
    bounces:0
  };

  function startRoll(){
    const reqPoly = polygonFromStats(req);
    const cReq = polygonCentroid(reqPoly);

    puck.active = true;
    puck.state = "rolling";
    puck.time = 0;
    puck.bounces = 0;

    puck.pos = { x: cReq.x + (Math.random()-0.5)*6, y: cReq.y + (Math.random()-0.5)*6 };
    if (!pointInPoly(puck.pos, reqPoly)) puck.pos = { ...cReq };

    const dir = randomUnit();
    puck.vel = mul(dir, START_SPEED);

    resultEl.textContent = "…";
    resultEl.className = "result";
  }

  function update(dt){
    if(!puck.active) return;

    const reqPoly = polygonFromStats(req);
    const next = add(puck.pos, mul(puck.vel, dt));

    puck.vel = mul(puck.vel, FRICTION);

    if(!pointInPoly(next, reqPoly)){
      const edge = nearestEdge(reqPoly, next);
      const e = sub(edge.b, edge.a);

      let n = { x: -e.y, y: e.x };
      const nLen = norm(n);
      n = { x: n.x / nLen, y: n.y / nLen };

      const toP = sub(next, edge.cp);
      if(dot(toP, n) < 0) n = { x: -n.x, y: -n.y };

      const pre = norm(puck.vel);
      puck.vel = reflect(puck.vel, n);
      const post = norm(puck.vel);
      const impact = Math.min(1, (pre + post) / (2 * START_SPEED));

      puck.pos = sub(next, mul(n, puck.r + 0.8));
      puck.bounces++;

      playRandomBounce(impact);
    } else {
      puck.pos = next;
    }

    puck.time += dt;

    const speed = norm(puck.vel);
    if(puck.time >= MIN_DURATION && (speed < STOP_SPEED || puck.time > MAX_DURATION || puck.bounces > MAX_BOUNCES)){
      puck.active = false;
      const ok = pointInPoly(puck.pos, polygonFromStats(char));
      puck.state = ok ? "success" : "fail";
      resultEl.textContent = ok ? "Succès" : "Échec";
      resultEl.className = "result " + (ok ? "ok" : "no");
      if (ok) playSuccess(); else playFail();
    }
  }

  function draw(){
    ctx.clearRect(0,0,cssW,cssH);

    ctx.fillStyle = COL.panelBg;
    ctx.fillRect(0,0,cssW,cssH);

    const outer = polygonFromStats({ Force:10,Vigueur:10,Mobilité:10,Charisme:10,Intelligence:10 });
    drawPoly(outer, COL.pentFill, null);

    drawGrid();

    drawPoly(polygonFromStats(req),  COL.reqFill,  COL.reqStroke, 2);
    drawPoly(polygonFromStats(char), COL.charFill, COL.charStroke, 2.5);

    drawIcons();
    drawPuck();
  }

  function drawPoly(pts, fill, stroke, w=1){
    ctx.beginPath();
    pts.forEach((p,i)=>i?ctx.lineTo(p.x,p.y):ctx.moveTo(p.x,p.y));
    ctx.closePath();
    if(fill){ ctx.fillStyle = fill; ctx.fill(); }
    if(stroke){ ctx.strokeStyle = stroke; ctx.lineWidth = w; ctx.stroke(); }
  }

  function drawGrid(){
    ctx.strokeStyle = COL.grid;
    ctx.lineWidth = 1;
    for(let k=2;k<=10;k+=2){
      const r=(k/10)*R;
      ctx.beginPath();
      STATS.forEach((_,i)=>{
        const a=deg(-90+i*72);
        const x=cx+Math.cos(a)*r, y=cy+Math.sin(a)*r;
        i?ctx.lineTo(x,y):ctx.moveTo(x,y);
      });
      ctx.closePath();
      ctx.stroke();
    }
  }

  function drawIcons(){
    if(!iconsReady) return;

    ctx.save();
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = "high";

    const iconSize = 56;
    const radius = R + 44;

    for (let i=0; i<STATS.length; i++) {
      const key = STATS[i];
      const img = iconImgs[key];
      if (!img || !img.complete) continue;

      const a = deg(-90 + i*72);
      const x = cx + Math.cos(a)*radius;
      const y = cy + Math.sin(a)*radius;

      ctx.drawImage(img, x - iconSize/2, y - iconSize/2, iconSize, iconSize);
    }

    ctx.restore();
  }

  function drawPuck(){
    let c = COL.puckRolling;
    if(puck.state === "success") c = COL.puckSuccess;
    if(puck.state === "fail") c = COL.puckFail;

    ctx.beginPath();
    ctx.arc(puck.pos.x, puck.pos.y, puck.r, 0, Math.PI*2);
    ctx.fillStyle = c;
    ctx.fill();
  }

  let last = performance.now();
  function loop(t){
    const dt = Math.min(0.033, (t-last)/1000);
    last = t;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  rollBtn.addEventListener("click", async () => {
    ensureAudio();
    await loadSounds();
    startRoll();
  });

  loadIcons();
  loadCharacters();
  requestAnimationFrame(loop);

})();
</script>

</body>
</html>
