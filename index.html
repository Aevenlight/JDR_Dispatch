<!-- index.html -->
<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Dispatch JDR</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <main class="app">
    <section class="panel panel-left">
      <header class="panel-header">
        <h1 class="title">Dispatch JDR</h1>
        <p class="subtitle">Test de compétence</p>
      </header>

      <div class="group">
        <h2 class="group-title">Stats du personnage</h2>
        <div id="charControls" class="controls"></div>
      </div>

      <div class="group">
        <h2 class="group-title">Stats requises</h2>
        <div id="reqControls" class="controls"></div>
      </div>

      <div class="actions">
        <button id="rollBtn" class="btn">Lancer</button>
        <div id="result" class="result">—</div>
      </div>
    </section>

    <section class="panel panel-right">
      <header class="panel-header">
        <h2 class="group-title">Résolution</h2>
      </header>

      <div class="canvas-wrap">
        <canvas id="c" width="760" height="520"></canvas>
      </div>
    </section>
  </main>

<script>
(() => {
  // =========================================
  // CONFIG
  // =========================================
  const STATS = ["Force","Vigueur","Mobilité","Charisme","Intelligence"];
  const ICONS = {
    Force: "icons/Force.png",
    Vigueur: "icons/Vigueur.png",
    Mobilité: "icons/Mobilité.png",
    Charisme: "icons/Charisme.png",
    Intelligence: "icons/Intelligence.png",
  };
  const MAX_STAT = 10;

  // Couleurs demandées
  const COL = {
    panelBg: "#fff0d9",
    pentFill: "#322a1f",
    grid: "#615a43",

    // Polygone perso (jaune)
    charFill: "rgba(255, 199, 58, 0.40)",   // #ffc73a @40%
    charStroke: "rgba(255, 199, 58, 1.00)",

    // Polygone requis (blanc cassé)
    reqFill: "rgba(255, 255, 249, 0.40)",  // #fffff9 @40%
    reqStroke: "rgba(255, 255, 249, 1.00)",

    // Puck
    puckRolling: "#000000",
    puckSuccess: "#6dc383",
    puckFail:    "#f98277",
  };

  // Simu
  const MIN_DURATION = 7.0; // rebonds >= 7s
  const MAX_DURATION = 9.0; // sécurité
  const START_SPEED  = 360; // px/s
  const FRICTION     = 0.992;
  const STOP_SPEED   = 18;  // vitesse en dessous => stop (après min duration)
  const MAX_BOUNCES  = 40;

  // =========================================
  // UI STATE (exemples)
  // =========================================
  const char = { Force:2, Vigueur:5, Mobilité:3, Charisme:2, Intelligence:3 };
  const req  = { Force:2, Vigueur:2, Mobilité:5, Charisme:5, Intelligence:2 };

  const charControls = document.getElementById("charControls");
  const reqControls  = document.getElementById("reqControls");
  const resultEl     = document.getElementById("result");
  const rollBtn      = document.getElementById("rollBtn");

  function mkSlider(container, obj, key) {
    const row = document.createElement("div");
    row.className = "row";

    const label = document.createElement("label");
    label.className = "lbl";
    label.textContent = key;

    const val = document.createElement("div");
    val.className = "val";
    val.textContent = obj[key];

    const rng = document.createElement("input");
    rng.className = "rng";
    rng.type = "range";
    rng.min = "0";
    rng.max = String(MAX_STAT);
    rng.value = String(obj[key]);

    rng.addEventListener("input", () => {
      obj[key] = Number(rng.value);
      val.textContent = obj[key];
      draw();
    });

    row.appendChild(label);
    row.appendChild(val);
    container.appendChild(row);
    container.appendChild(rng);
  }

  STATS.forEach(k => mkSlider(charControls, char, k));
  STATS.forEach(k => mkSlider(reqControls,  req,  k));

  // =========================================
  // CANVAS SETUP
  // =========================================
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  const pad = 26;
  const inner = { x: pad, y: pad, w: canvas.width - pad*2, h: canvas.height - pad*2 };

  const cx = inner.x + inner.w * 0.55;
  const cy = inner.y + inner.h * 0.52;
  const R  = Math.min(inner.w, inner.h) * 0.38;

  function degToRad(d){ return d * Math.PI / 180; }
  function norm(v){ return Math.hypot(v.x,v.y) || 1e-9; }
  function dot(a,b){ return a.x*b.x + a.y*b.y; }
  function sub(a,b){ return {x:a.x-b.x,y:a.y-b.y}; }
  function add(a,b){ return {x:a.x+b.x,y:a.y+b.y}; }
  function mul(a,s){ return {x:a.x*s,y:a.y*s}; }

  function randomUnit() {
    const a = Math.random() * Math.PI * 2;
    return { x: Math.cos(a), y: Math.sin(a) };
  }

  function polygonFromStats(statsObj) {
    const pts = [];
    for (let i=0; i<STATS.length; i++) {
      const a = degToRad(-90 + i * 360 / STATS.length);
      const v = statsObj[STATS[i]] ?? 0;
      const r = (v / MAX_STAT) * R;
      pts.push({ x: cx + r * Math.cos(a), y: cy + r * Math.sin(a) });
    }
    return pts;
  }

  // Point in polygon (ray casting)
  function pointInPoly(pt, poly) {
    let inside = false;
    for (let i=0, j=poly.length-1; i<poly.length; j=i++) {
      const xi = poly[i].x, yi = poly[i].y;
      const xj = poly[j].x, yj = poly[j].y;
      const intersect = ((yi > pt.y) !== (yj > pt.y)) &&
        (pt.x < (xj - xi) * (pt.y - yi) / ((yj - yi) || 1e-9) + xi);
      if (intersect) inside = !inside;
    }
    return inside;
  }

  function closestPointOnSegment(p, a, b) {
    const abx = b.x - a.x, aby = b.y - a.y;
    const apx = p.x - a.x, apy = p.y - a.y;
    const ab2 = abx*abx + aby*aby || 1e-9;
    let t = (apx*abx + apy*aby) / ab2;
    t = Math.max(0, Math.min(1, t));
    return { x: a.x + t*abx, y: a.y + t*aby, t };
  }

  function nearestEdge(poly, p) {
    let best = { dist: Infinity, a:null, b:null, cp:null };
    for (let i=0; i<poly.length; i++) {
      const a = poly[i];
      const b = poly[(i+1)%poly.length];
      const cp = closestPointOnSegment(p, a, b);
      const dx = p.x - cp.x, dy = p.y - cp.y;
      const dist = Math.hypot(dx,dy);
      if (dist < best.dist) best = { dist, a, b, cp };
    }
    return best;
  }

  // Reflect v across unit normal n
  function reflect(v, nUnit) {
    const d = dot(v, nUnit);
    return sub(v, mul(nUnit, 2*d));
  }

  // Polygon centroid (shoelace)
  function polygonCentroid(poly) {
    let a = 0, cxAcc = 0, cyAcc = 0;
    for (let i=0; i<poly.length; i++) {
      const p = poly[i];
      const q = poly[(i+1)%poly.length];
      const cross = p.x*q.y - q.x*p.y;
      a += cross;
      cxAcc += (p.x + q.x) * cross;
      cyAcc += (p.y + q.y) * cross;
    }
    a *= 0.5;
    if (Math.abs(a) < 1e-9) {
      const m = poly.reduce((acc, p) => ({x: acc.x + p.x, y: acc.y + p.y}), {x:0,y:0});
      return { x: m.x / poly.length, y: m.y / poly.length };
    }
    return { x: cxAcc / (6*a), y: cyAcc / (6*a) };
  }

  // =========================================
  // ICONS PRELOAD
  // =========================================
  const iconImgs = {};
  let iconsReady = false;

  function loadIcons() {
    const promises = STATS.map(k => new Promise((resolve) => {
      const img = new Image();
      img.onload = () => resolve(true);
      img.onerror = () => resolve(false);
      img.src = ICONS[k];
      iconImgs[k] = img;
    }));
    Promise.all(promises).then(() => {
      iconsReady = true;
      draw();
    });
  }
  loadIcons();

  // =========================================
  // PUCK
  // =========================================
  const puck = {
    active: false,
    state: "idle", // "idle" | "rolling" | "success" | "fail"
    pos: {x: cx, y: cy},
    vel: {x: 0, y: 0},
    r: 8,
    time: 0,
    bounces: 0
  };

  function startRoll() {
    const reqPoly = polygonFromStats(req);

    puck.active = true;
    puck.state = "rolling";
    puck.time = 0;
    puck.bounces = 0;

    // spawn at centroid of required polygon
    const cReq = polygonCentroid(reqPoly);
    puck.pos = {
      x: cReq.x + (Math.random() - 0.5) * 6,
      y: cReq.y + (Math.random() - 0.5) * 6
    };
    if (!pointInPoly(puck.pos, reqPoly)) puck.pos = { ...cReq };

    const dir = randomUnit();
    puck.vel = mul(dir, START_SPEED);

    resultEl.textContent = "…";
    resultEl.className = "result";
  }

  function update(dt) {
    if (!puck.active) return;

    const reqPoly = polygonFromStats(req);
    const next = add(puck.pos, mul(puck.vel, dt));

    // friction
    puck.vel = mul(puck.vel, FRICTION);

    // bounce on required polygon boundary
    if (!pointInPoly(next, reqPoly)) {
      const edge = nearestEdge(reqPoly, next);
      const e = sub(edge.b, edge.a);

      // normal
      let n = { x: -e.y, y: e.x };
      const nLen = norm(n);
      n = { x: n.x / nLen, y: n.y / nLen };

      // orient normal toward the point
      const toP = sub(next, edge.cp);
      if (dot(toP, n) < 0) n = mul(n, -1);

      puck.vel = reflect(puck.vel, n);

      // push slightly inside
      puck.pos = sub(next, mul(n, puck.r + 0.8));
      puck.bounces++;
    } else {
      puck.pos = next;
    }

    puck.time += dt;

    // stop conditions (min duration)
    const speed = norm(puck.vel);
    const canStop = puck.time >= MIN_DURATION;

    if (canStop && (speed < STOP_SPEED || puck.time > MAX_DURATION || puck.bounces > MAX_BOUNCES)) {
      puck.active = false;

      const charPoly = polygonFromStats(char);
      const ok = pointInPoly(puck.pos, charPoly);

      puck.state = ok ? "success" : "fail";

      resultEl.textContent = ok ? "Succès" : "Échec";
      resultEl.className = ok ? "result ok" : "result no";
    }
  }

  // =========================================
  // DRAWING
  // =========================================
  function drawWindowBackground() {
    ctx.save();
    ctx.fillStyle = COL.panelBg;
    ctx.fillRect(0,0,canvas.width,canvas.height);

    ctx.strokeStyle = "rgba(48, 28, 2, 0.35)";
    ctx.lineWidth = 2;
    ctx.strokeRect(1,1,canvas.width-2,canvas.height-2);

    ctx.strokeStyle = "rgba(48, 28, 2, 0.18)";
    ctx.lineWidth = 1;
    ctx.strokeRect(10,10,canvas.width-20,canvas.height-20);
    ctx.restore();
  }

  function drawPentagonBackdrop() {
    const outer = polygonFromStats({
      Force: MAX_STAT, Vigueur: MAX_STAT, Mobilité: MAX_STAT, Charisme: MAX_STAT, Intelligence: MAX_STAT
    });

    ctx.save();
    ctx.beginPath();
    outer.forEach((p,i)=> i?ctx.lineTo(p.x,p.y):ctx.moveTo(p.x,p.y));
    ctx.closePath();
    ctx.fillStyle = COL.pentFill;
    ctx.fill();
    ctx.restore();
  }

  function drawRadarGrid() {
    ctx.save();
    ctx.lineWidth = 1;
    ctx.strokeStyle = COL.grid;

    // rings
    for (let k=2; k<=10; k+=2) {
      const rr = (k/MAX_STAT)*R;
      ctx.beginPath();
      for (let i=0; i<STATS.length; i++) {
        const a = degToRad(-90 + i * 360 / STATS.length);
        const x = cx + rr * Math.cos(a);
        const y = cy + rr * Math.sin(a);
        if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.closePath();
      ctx.stroke();
    }

    // axes
    for (let i=0; i<STATS.length; i++) {
      const a = degToRad(-90 + i * 360 / STATS.length);
      const x2 = cx + R * Math.cos(a);
      const y2 = cy + R * Math.sin(a);
      ctx.beginPath();
      ctx.moveTo(cx,cy);
      ctx.lineTo(x2,y2);
      ctx.stroke();
    }

    ctx.restore();
  }

  function drawPolygon(pts, fill, stroke, width=2) {
    ctx.save();
    ctx.beginPath();
    pts.forEach((p,i)=> i?ctx.lineTo(p.x,p.y):ctx.moveTo(p.x,p.y));
    ctx.closePath();
    ctx.fillStyle = fill;
    ctx.fill();
    ctx.strokeStyle = stroke;
    ctx.lineWidth = width;
    ctx.stroke();
    ctx.restore();
  }

  function drawIcons() {
    if (!iconsReady) return;

    const iconSize = 34;
    const radius = R + 30;

    for (let i=0; i<STATS.length; i++) {
      const key = STATS[i];
      const img = iconImgs[key];
      if (!img) continue;

      const a = degToRad(-90 + i * 360 / STATS.length);
      const x = cx + radius * Math.cos(a);
      const y = cy + radius * Math.sin(a);

      // badge
      ctx.save();
      ctx.beginPath();
      ctx.arc(x, y, iconSize/2 + 8, 0, Math.PI*2);
      ctx.fillStyle = "rgba(255,240,217,0.9)";
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(48,28,2,0.35)";
      ctx.stroke();

      ctx.drawImage(img, x - iconSize/2, y - iconSize/2, iconSize, iconSize);
      ctx.restore();
    }
  }

  function puckColor() {
    if (puck.state === "success") return COL.puckSuccess;
    if (puck.state === "fail") return COL.puckFail;
    // idle or rolling => black
    return COL.puckRolling;
  }

  function drawPuck() {
    ctx.save();
    ctx.beginPath();
    ctx.arc(puck.pos.x, puck.pos.y, puck.r, 0, Math.PI*2);
    ctx.fillStyle = puckColor();
    ctx.fill();

    // contour léger
    ctx.lineWidth = 2;
    ctx.strokeStyle = "rgba(0,0,0,0.25)";
    ctx.stroke();
    ctx.restore();
  }

  function draw() {
    drawWindowBackground();

    // radar
    drawPentagonBackdrop();
    drawRadarGrid();

    // polygons
    const reqPoly  = polygonFromStats(req);
    const charPoly = polygonFromStats(char);

    drawPolygon(reqPoly,  COL.reqFill,  COL.reqStroke, 2);
    drawPolygon(charPoly, COL.charFill, COL.charStroke, 2.5);

    // icons
    drawIcons();

    // puck
    drawPuck();
  }

  // =========================================
  // LOOP
  // =========================================
  let last = performance.now();
  function loop(t) {
    const dt = Math.min(0.033, (t - last) / 1000);
    last = t;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  rollBtn.addEventListener("click", startRoll);

  draw();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
